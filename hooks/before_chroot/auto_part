#!/bin/bash

# Automatically create disk partitions.
# * Create RAID1 if two largest devices has same capacity.
# * Do not create new partition table if partitions layout matches predefined
#   partition policy.

echo "[$0]"

SWAP_LABEL='atm-swap'
BOOT_LABEL='atm-boot'
ROOT_LABEL='atm-deepin'
BACK_LABEL='atm-backup'
LOGS_LABEL='atm-logs'
ONE_MIB=1048576

warn() {
  local msg="$@"
  echo "!! Warning: ${msg}" >&2
}

# Print error message and exit current executation context.
error() {
  local msg="$@"
  echo "!! Error: ${msg}" >&2
  exit 1;
}

# Path to installer configuration file.
CONF_FILE='/etc/deepin-installer.conf'

# Mimumum disk capacity required, 30GiB.
MININUM_DISK_SIZE=30720

# Returns 0 if $1 is a usb device.
is_usb_disk_device() {
  local dev=$1
  udevadm info $dev | grep -q 'ID_BUS=usb'
}

# Returns largest (at most two) disk devices in system.
get_largest_disk_devices() {
  local disk_names
  local disk_paths
  local disk_path
  local disk_count=0
  # Sort by disk size, then by disk name.
  disk_names=$(lsblk -io KNAME,TYPE,SIZE | grep disk | sort -k3,3hr -k1,1 | \
               awk '{ print $1}')

  for disk_name in $disk_names; do
    disk_path=/dev/$disk_name
    if ! $(is_usb_disk_device $disk_path); then
      if [ -z $disk_paths ]; then
        disk_paths=$disk_path
      else
        disk_paths="$disk_paths:$disk_path"
      fi
      disk_count=$((disk_count + 1))
      if [ $disk_count -eq 2 ]; then
        echo $disk_paths
        return
      fi
    fi
  done
  echo "$disk_paths"
}

prepare_for_partitioning() {
  # Umount all swap partitions.
  swapoff -a

  cp -vf "/usr/share/deepin-installer/templates/lfs-atm.conf" "${CONF_FILE}"

  # Remote group name. Group name starts with [
  sed -i -e '/\[/d' "${CONF_FILE}"
}

# Notify kernel about device partition change.
commit_to_os() {
  partprobe
  udevadm settle --timeout=3
}

# Check whether RAID1 is supported on machine.
is_raid_supported() {
  echo "is_raid_supported()"
  local dev1 dev2
  local devices
  devices=$(get_largest_disk_devices)
  echo "devices $devices"
  dev1=${devices%:*}
  dev2=${devices##*:}
  if test -z $dev1 || test -z $dev2 ; then
    return 1
  else
    return 0
  fi
}

# Check whether current partition list fit normal partition policy.
# If it is matched, there is no need to reformat whole disk again.
check_normal_partition_map() {
  local dev=$1
  local dev_size
  dev_size=$(blockdev --getsize64 $dev)
  dev_size=$((dev_size / ONE_MIB))
  local swap_size=4095
  local swap_end=4096
  local remaining_size=$((dev_size - swap_end))
  local root_size=$((remaining_size * 2 / 5))
  local root_end=$((remaining_size * 2 / 5 + swap_end))
  local log_size=$((remaining_size * 2 / 5))
  local log_end=$((remaining_size * 4 / 5 + swap_end))

  local policy=("1:swap:${swap_size}" "2:ext4:${root_size}" "3:ext4:${log_size}")
  local part_path
  local part_real_size
  for item in ${policy[@]}; do
    read part_num fstype part_size < <(echo ${item} | \
      awk -F':' '{print $1, $2, $3}')

    part_path=${dev}$part_num
    [ -b ${part_path} ] || return 1

    read real_fstype real_size < <(lsblk ${part_path} -o FSTYPE,SIZE -b -n)
    real_size=$((real_size / ONE_MIB))
    if [ x"${fstype}" != x"${real_fstype}" ] || \
      [ ${real_size} -lt $((part_size - 50)) ] || \
      [ ${real_size} -gt $((part_size + 50)) ]; then
      echo "not match: $item => ${real_fstype}, ${real_size}"
      return 1
    fi
  done
  return 0
}

# Create normal partitions with predefined policy.
# * 4GiB swap;
# * 40% for / with ext4 filesystem;
# * 40% for /var/log with ext4 filesystem;
# * 20% for backup with ext4 filesystem, no mount point;
create_normal_partitions() {
  local device=''
  device=$(get_largest_disk_devices)
  device=/dev/sda
  if [ -z $device ]; then
    warn 'No appropriate storage device found!'
    warn 'There shall be an IDE/SATA/SCIS disk at /dev/sda or /dev/hda'
    return 1
  fi

  if check_normal_partition_map $device; then
    # Only format / partition.
    echo "partitioning policy match"
    mkfs.ext4 -F -L $ROOT_LABEL ${device}2 || return 1
  else
    echo "create normal partitions on device: $device"
    local dev_size
    dev_size=$(blockdev --getsize64 $device)
    dev_size=$((dev_size / ONE_MIB))
    local swap_end=4096
    local remaining_size=$((dev_size - swap_end))
    local root_end=$((remaining_size * 2 / 5 + swap_end))
    local log_end=$((remaining_size * 4 / 5 + swap_end))
    parted $device -s mklabel msdos && \
      parted $device -s mkpart primary linux-swap 1MiB 4096MiB && \
      parted $device -s mkpart primary ext4 4096MiB ${root_end}MiB && \
      parted $device -s mkpart primary ext4 ${root_end}MiB ${log_end}MiB && \
      parted $device -s mkpart primary ext4 ${log_end}MiB 100% && \
      commit_to_os && \
      mkswap -L $SWAP_LABEL ${device}1 && \
      mkfs.ext4 -F -L $ROOT_LABEL ${device}2 && \
      mkfs.ext4 -F -L $LOGS_LABEL ${device}3 && \
      mkfs.ext4 -F -L $BACK_LABEL ${device}4 ||
      return 1
  fi

  # Write bootloader info into conf.
  sed -i "s|DI_BOOTLOADER=.*$|DI_BOOTLOADER=\"$device\"|" $CONF_FILE
  sed -i "s|DI_ROOT_DISK=.*$|DI_ROOT_DISK=\"$device\"|" $CONF_FILE
  sed -i "s|DI_ROOT_PARTITION=.*$|DI_ROOT_PARTITION=\"${device}2\"|" $CONF_FILE
  local mp="${device}1=swap;${device}3=/var/log"
  sed -i "s|DI_MOUNTPOINTS=.*$|DI_MOUNTPOINTS=\"${mp}\"|" $CONF_FILE
}

# Check whether current partitions match expected RAID1 partitioning policy.
check_raid1_partition_map() {
  local device=$1
  echo "check raid1 partition map on ${device}"
  local part1 part2 part3
  part1=$(lsblk -rno LABEL ${device}1)
  if [ x${part1} != x${BOOT_LABEL} ]; then
    echo "part1 not match, ${part1} != ${BOOT_LABEL}"
    return 1
  fi

  part2=$(lsblk -rno LABEL ${device}2)
  if [ x${part2} != x${SWAP_LABEL} ]; then
    echo "part2 not match ${part2} != ${SWAP_LABEL}"
    return 1
  fi

  part3=$(lsblk -rno LABEL ${device}3 | sort -r)
  if grep -q ${ROOT_LABEL} <<< ${part3} &&
     grep -q ${BACK_LABEL} <<< ${part3} &&
     grep -q ${LOGS_LABEL} <<< ${part3}; then
    return 0
  fi

  echo "part 3 not match"

  return 1
}

# Remove any existing raid devices before creating new one.
remove_raid_devices() {
  local mddev=$1
  mdadm --stop "${mddev}"
  mdadm --remove "${mddev}"
}

# Create physical partitions for RAID1 device.
#  * 4GiB for swap
#  * 40% for /
#  * 40% for /var/log
#  * remaining for backup
create_partitions_for_raid1() {
  local device=$1
  local capacity=$2
  parted $device -s mklabel msdos && \
    parted $device -s mkpart primary ext2 1MiB 4096MiB && \
    parted $device -s set 1 raid on && \
    parted $device -s mkpart primary ext2 4096MiB 40% && \
    parted $device -s set 2 boot on && \
    parted $device -s set 2 raid on && \
    parted $device -s mkpart primary ext2 40% 80% && \
    parted $device -s set 3 raid on && \
    parted $device -s mkpart primary ext2 80% 100% && \
    parted $device -s set 4 raid on
}

# Create RAID1 device.
create_md_raid1() {
  local part1=$1
  local part2=$2
  local raid_dev=$3
  yes | mdadm --create $raid_dev --level=raid1 --raid-devices=2 $part1 $part2
}

# Create partitions and filesystem on RAID1 device.
# * 40% for / with ext4 filesystem;
# * 40% for /var/log with ext4 filesystem;
# * 20% for backup, no mount point.
create_raid1_partitions() {
  local raid_dev=$1
  parted $raid_dev -s mklabel msdos && \
    parted $raid_dev -s mkpart primary ext4 1MiB 40% && \
    parted $raid_dev -s mkpart primary ext4 40% 80% && \
    parted $raid_dev -s mkpart primary ext4 80% 100% && \
    commit_to_os && \
    mkfs.ext4 -F -L "${ROOT_LABEL}" ${raid_dev}p1 && \
    mkfs.ext4 -F -L "${LOGS_LABEL}" ${raid_dev}p2 && \
    mkfs.ext4 -F -L "${BACK_LABEL}" ${raid_dev}p3
}

# Create RAID1 partitions based on predefined policy.
create_raid_partitions() {
  local dev1 dev2
  local devices
  devices=$(get_largest_disk_devices)
  dev1=${devices%:*}
  dev2=${devices##*:}
  echo "dev1: $dev1, dev2: $dev2"
  if test -z $dev1 || test -z $dev2 ; then
    warn "No appropriate device found for RAID1"
    return 1
  fi

  # TODO(LiuLang): remove any RAID devices first.

  if check_raid1_partition_map $dev1 && check_raid1_partition_map $dev2; then
    echo "RAID1 policy match"
    # TODO(LiuLang): Format / on raid1 device
  else
    echo "RAID1 policy not match"
    echo "Create RAID1 partitions on $dev1 and $dev2"
    create_partitions_for_raid1 $dev1 || return 1
    create_partitions_for_raid1 $dev2 || return 2

    commit_to_os

    yes | mdadm -C /dev/md0 -l 1 -n 2 ${dev1}1 ${dev2}1 && \
      yes | mdadm -C /dev/md1 -l 1 -n 2 ${dev1}2 ${dev2}2 && \
      yes | mdadm -C /dev/md2 -l 1 -n 2 ${dev1}3 ${dev2}3 && \
      yes | mdadm -C /dev/md3 -l 1 -n 2 ${dev1}4 ${dev2}4 && \
      commit_to_os && \
      mkswap -L $SWAP_LABEL /dev/md0 && \
      mkfs.ext4 -F -L $ROOT_LABEL /dev/md1 && \
      mkfs.ext4 -F -L $LOGS_LABEL /dev/md2 && \
      mkfs.ext4 -F -L $BACK_LABEL /dev/md3 ||
      return 5
  fi

  # Write bootloader info into conf.
  sed -i "s|DI_BOOTLOADER=.*$|DI_BOOTLOADER=\"$dev1\"|" $CONF_FILE
  sed -i "s|DI_ROOT_DISK=.*$|DI_ROOT_DISK=\"$dev1\"|" $CONF_FILE
  sed -i "s|DI_ROOT_PARTITION=.*$|DI_ROOT_PARTITION=/dev/md1p1|" \
    $CONF_FILE

  local mp="/dev/md0p1=swap"
  mp=${mp}";/dev/md1p1=/"
  mp=${mp}";/dev/md2p1=/var/log"
  sed -i "s|DI_MOUNTPOINTS=.*$|DI_MOUNTPOINTS=\"${mp}\"|" $CONF_FILE
}

main() {
  prepare_for_partitioning
  if is_raid_supported; then
    echo 'Create RAID1 partitions'
    create_raid_partitions ||
      error 'Failed to create RAID1 partitions'
  else
    echo 'Create normal partitions'
    create_normal_partitions ||
      error 'Failed to create normal partitions'
  fi
}

#main
create_normal_partitions

exit 0
