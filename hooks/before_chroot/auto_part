#!/bin/bash

# Automatically create disk partitions.
# * Create RAID1 if two largest devices has same capacity.
# * Do not create new partition table if partitions layout matches predefined
#   partition policy.

echo "[$0]"

SWAP_LABEL='atm-swap'
BOOT_LABEL='atm-boot'
ROOT_LABEL='atm-deepin'
BACK_LABEL='atm-backup'
LOGS_LABEL='atm-logs'

warn() {
  local msg="$@"
  echo "!! Warning: ${msg}" >&2
}

# Print error message and exit current executation context.
error() {
  local msg="$@"
  echo "!! Error: ${msg}" >&2
  exit 1;
}

# Path to installer configuration file.
CONF_FILE='/etc/deepin-installer.conf'

# Mimumum disk capacity required, 30GiB.
MININUM_DISK_SIZE=30720

# The disk with largest storage capacity is used as system device.
get_max_capacity_device() {
  local device=''
  local max_capacity=0
  lsblk -ndb -o name,size 2>/dev/null | \
    (while read name size; do
      if test $max_capacity -lt $size && test $size -gt $MININUM_DISK_SIZE; then
        max_capacity=$size
        device=$name
      fi
    done && echo /dev/$device)
}

# Returns device paths with largest storage capacity.
# Returns nothing if no devices with same capacity found.
# e.g. /dev/sda /dev/sdb
get_max_capacity_devices_for_raid() {
  local device1=''
  local device2=''
  local max_capacity=$MININUM_DISK_SIZE
  lsblk -ndb -o name,size 2>/dev/null | \
    (while read name size; do
      if [ $size -eq $max_capacity ]; then
        device2=$name
      elif [ $size -gt $max_capacity ]; then
        device1=$name
        device2=''
        max_capacity=$size
      fi
    done && echo "$device1:$device2")
}

prepare_for_partitioning() {
  # Umount all swap partitions.
  swapoff -a

  cp -vf "/usr/share/deepin-installer/templates/lfs-atm.conf" "${CONF_FILE}"

  # Remote group name. Group name starts with [
  sed -i -e '/\[/d' "${CONF_FILE}"
}

# Notify kernel about device partition change.
commit_to_os() {
  partprobe
  udevadm settle --timeout=3
}

# Check whether RAID1 is supported on machine.
is_raid_supported() {
  local dev1 dev2
  local devices
  devices=$(get_max_capacity_devices_for_raid)
  dev1=${devices%:*}
  dev2=${devices##*:}
  if test -z $dev1 || test -z $dev2 ; then
    return 1
  else
    return 0
  fi
}

# Check whether current partition list fit normal partition policy.
# If it is matched, there is no need to reformat whole disk again.
check_normal_partition_map() {
  return 0
}

# Create normal partitions with predefined policy.
# * 4GiB swap;
# * 40% for / with ext4 filesystem;
# * 40% for /var/log with ext4 filesystem;
# * 20% for backup with ext4 filesystem, no mount point;
create_normal_partitions() {
  local device=''
  device=$(get_max_capacity_device)
  if [ -z $device ]; then
    warn 'No appropriate storage device found!'
    warn 'There shall be an IDE/SATA/SCIS disk at /dev/sda or /dev/hda'
    return 1
  fi

  echo "create normal partition device: $device"

  parted $device -s mklabel msdos && \
    parted $device -s mkpart primary linux-swap 1MiB 4096MiB && \
    parted $device -s mkpart primary ext4 4096MiB 40% && \
    parted $device -s mkpart primary ext4 40% 80% && \
    parted $device -s mkpart primary ext4 80% 100% && \
    commit_to_os && \
    mkswap -L "${SWAP_LABEL}" ${device}1 && \
    mkfs.ext4 -F -L "${ROOT_LABEL}" ${device}2 && \
    mkfs.ext4 -F -L "${LOGS_LABEL}" ${device}3 && \
    mkfs.ext4 -F -L "${BACK_LABEL}" ${device}4 ||
    return 1

  # Write bootloader info into conf.
  sed -i "s|DI_BOOTLOADER=.*$|DI_BOOTLOADER=\"$device\"|" $CONF_FILE
  sed -i "s|DI_ROOT_DISK=.*$|DI_ROOT_DISK=\"$device\"|" $CONF_FILE
  sed -i "s|DI_ROOT_PARTITION=.*$|DI_ROOT_PARTITION=\"${device}2\"|" $CONF_FILE
  local mp="${device}1=swap;${device}3=/var/log"
  sed -i "s|DI_MOUNTPOINTS=.*$|DI_MOUNTPOINTS=\"${mp}\"|" $CONF_FILE
}

# Check whether current partitions match expected RAID1 partitioning policy.
check_raid1_partition_map() {
  local device=$1
  echo "check raid1 partition map on ${device}"
  local part1 part2 part3
  part1=$(lsblk -rno LABEL ${device}1)
  if [ x${part1} != x${BOOT_LABEL} ]; then
    echo "part1 not match, ${part1} != ${BOOT_LABEL}"
    return 1
  fi

  part2=$(lsblk -rno LABEL ${device}2)
  if [ x${part2} != x${SWAP_LABEL} ]; then
    echo "part2 not match ${part2} != ${SWAP_LABEL}"
    return 1
  fi

  part3=$(lsblk -rno LABEL ${device}3 | sort -r)
  if grep -q ${ROOT_LABEL} <<< ${part3} &&
     grep -q ${BACK_LABEL} <<< ${part3} &&
     grep -q ${LOGS_LABEL} <<< ${part3}; then
    return 0
  fi

  echo "part 3 not match"

  return 1
}

# Remove any existing raid devices before creating new one.
remove_raid_devices() {
  local mddev=$1
  mdadm --stop "${mddev}"
  mdadm --remove "${mddev}"
}

# Create physical partitions for RAID1 device.
# Also create swap partition and boot partition.
# * 1GiB for /boot;
# * 4GiB for swap;
# * Remaining space used as RAID1 partition;
create_partitions_for_raid1() {
  local device=$1
  parted $device -s mklabel msdos && \
    parted $device -s mkpart primary ext4 1MiB 1024MiB && \
    parted $device -s set 1 boot on && \
    parted $device -s mkpart primary linux-swap 1024MiB 5120MiB && \
    parted $device -s mkpart primary ext2 5120MiB 100% && \
    parted $device -s set 3 raid on && \
    commit_to_os && \
    mkfs.ext4 -L "${BOOT_LABEL}" -F ${device}1 && \
    mkswap -L "${SWAP_LABEL}" ${device}2
}

# Create RAID1 device.
create_md_raid1() {
  local part1=$1
  local part2=$2
  local raid_dev=$3
  yes | mdadm --create $raid_dev --level=raid1 --raid-devices=2 $part1 $part2
}

# Create partitions and filesystem on RAID1 device.
# * 40% for / with ext4 filesystem;
# * 40% for /var/log with ext4 filesystem;
# * 20% for backup, no mount point.
create_raid1_partitions() {
  local raid_dev=$1
  parted $raid_dev -s mklabel msdos && \
    parted $raid_dev -s mkpart primary ext4 1MiB 40% && \
    parted $raid_dev -s mkpart primary ext4 40% 80% && \
    parted $raid_dev -s mkpart primary ext4 80% 100% && \
    commit_to_os && \
    mkfs.ext4 -F -L "${ROOT_LABEL}" ${raid_dev}p1 && \
    mkfs.ext4 -F -L "${LOGS_LABEL}" ${raid_dev}p2 && \
    mkfs.ext4 -F -L "${BACK_LABEL}" ${raid_dev}p3
}

# Create RAID1 partitions based on predefined policy.
create_raid_partitions() {
  local raid_dev=/dev/md0

  local dev1 dev2
  local devices
  devices=$(get_max_capacity_devices_for_raid)
  dev1=${devices%:*}
  dev2=${devices##*:}
  if test -z $dev1 || test -z $dev2 ; then
    warn "No appropriate device found for RAID1"
    return 1
  fi
  dev1=/dev/$dev1
  dev2=/dev/$dev2

  if check_raid1_partition_map $dev1 && check_raid1_partition_map $dev2; then
    echo "RAID1 policy match"
    # TODO(LiuLang): Format / on raid1 device
  else
    echo "RAID1 policy not match"
  fi

  exit 0

  echo "Create RAID1 partitions on $dev1 and $dev2"

  create_partitions_for_raid1 $dev1 || return 1
  create_partitions_for_raid1 $dev2 || return 2
  # Both /dev/sda3 and /dev/sdb3 are raid physical partitions
  create_md_raid1 ${dev1}3 ${dev2}3 $raid_dev || return 3
  create_raid1_partitions $raid_dev || return 4
  # Write bootloader info into conf.
  sed -i "s|DI_BOOTLOADER=.*$|DI_BOOTLOADER=\"$dev1\"|" $CONF_FILE
  sed -i "s|DI_ROOT_DISK=.*$|DI_ROOT_DISK=\"$dev1\"|" $CONF_FILE
  sed -i "s|DI_ROOT_PARTITION=.*$|DI_ROOT_PARTITION=\"${raid_dev}p1\"|" \
    $CONF_FILE
  local mp="${dev1}1=/boot"
  mp=${mp}";${dev1}2=swap"
  mp=${mp}";${raid_dev}p1=/"
  mp=${mp}";${raid_dev}p2=/var/log"
  sed -i "s|DI_MOUNTPOINTS=.*$|DI_MOUNTPOINTS=\"${mp}\"|" $CONF_FILE
}

main() {
  prepare_for_partitioning
  if is_raid_supported; then
    echo 'Create RAID1 partitions'
    create_raid_partitions ||
      error 'Failed to create RAID1 partitions'
  else
    echo 'Create normal partitions'
    create_normal_partitions ||
      error 'Failed to create normal partitions'
  fi
}

main

exit 0
